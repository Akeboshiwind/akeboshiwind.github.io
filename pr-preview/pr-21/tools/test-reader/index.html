<!DOCTYPE html><html lang="en"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Lateral Flow Test Reader | Blog by the Rocks</title><meta name="description" content="Analyze lateral flow test strips (COVID, ovulation, etc.) and track results over time"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="shortcut icon" href="/favicon.ico"><style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 500px;
      margin: 0 auto;
      width: 100%;
    }

    .back-link {
      color: #667eea;
      text-decoration: none;
      font-size: 0.9rem;
      display: inline-block;
      margin-bottom: 15px;
    }

    .back-link:hover {
      text-decoration: underline;
    }

    h1 {
      font-size: 1.4rem;
      margin-bottom: 20px;
      text-align: center;
    }

    .upload-area {
      border: 2px dashed #444;
      border-radius: 12px;
      padding: 40px 20px;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.2s;
      margin-bottom: 20px;
    }

    .upload-area:hover {
      border-color: #667eea;
    }

    .upload-area input {
      display: none;
    }

    .upload-btn {
      width: 100%;
      padding: 16px;
      border: none;
      border-radius: 8px;
      background: #667eea;
      color: white;
      font-size: 1rem;
      cursor: pointer;
      margin-bottom: 10px;
    }

    .upload-btn:hover {
      background: #5a67d8;
    }

    .upload-btn.secondary {
      background: #374151;
    }

    .upload-btn.secondary:hover {
      background: #4b5563;
    }

    .controls {
      display: none;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 15px;
      background: #252542;
      padding: 15px;
      border-radius: 8px;
    }

    .control-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .control-row label {
      font-size: 14px;
      color: #aaa;
      min-width: 50px;
    }

    .control-row input[type="range"] {
      flex: 1;
      height: 6px;
      -webkit-appearance: none;
      background: #444;
      border-radius: 3px;
      outline: none;
    }

    .control-row input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: #667eea;
      border-radius: 50%;
      cursor: pointer;
    }

    .control-row input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: #667eea;
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

    #rotationValue {
      min-width: 40px;
      text-align: right;
      font-size: 14px;
      color: #aaa;
    }

    .control-btn {
      padding: 10px 16px;
      border: none;
      border-radius: 6px;
      background: #374151;
      color: white;
      font-size: 0.9rem;
      cursor: pointer;
    }

    .control-btn:hover {
      background: #4b5563;
    }

    .control-divider {
      width: 1px;
      height: 24px;
      background: #444;
      margin: 0 5px;
    }

    .control-hint {
      font-size: 12px;
      color: #888;
    }

    .crop-handle {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 12px;
      cursor: ew-resize;
      background: rgba(102, 126, 234, 0.6);
      z-index: 10;
    }

    .crop-handle:hover {
      background: rgba(102, 126, 234, 0.9);
    }

    .crop-left { left: 0; }
    .crop-right { right: 0; }

    .crop-overlay {
      position: absolute;
      top: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      pointer-events: none;
    }

    .crop-overlay-left { left: 0; width: 0; }
    .crop-overlay-right { right: 0; width: 0; }

    .zoom-slider-container {
      position: absolute;
      bottom: 10px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      gap: 8px;
      z-index: 15;
      pointer-events: none;
    }

    .zoom-slider-track {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 12px;
      border-radius: 20px;
      pointer-events: auto;
    }

    .zoom-slider-track label {
      font-size: 12px;
      color: #aaa;
    }

    .zoom-slider-track input[type="range"] {
      width: 100px;
      height: 4px;
      -webkit-appearance: none;
      background: #444;
      border-radius: 2px;
      outline: none;
    }

    .zoom-slider-track input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: #667eea;
      border-radius: 50%;
      cursor: pointer;
    }

    .zoom-slider-track input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      background: #667eea;
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

    .zoom-slider-track span {
      font-size: 11px;
      color: #888;
      min-width: 32px;
      text-align: center;
    }

    .canvas-container {
      position: relative;
      display: none;
      margin-bottom: 20px;
      touch-action: none;
    }

    #mainCanvas {
      width: 100%;
      border-radius: 8px;
      display: block;
    }

    .marker {
      position: absolute;
      left: 0;
      right: 0;
      height: 3px;
      cursor: ns-resize;
      display: flex;
      align-items: center;
    }

    .marker::before {
      content: '';
      flex: 1;
      height: 2px;
      border-top: 2px dashed;
    }

    .marker-label {
      position: absolute;
      right: -60px;
      font-size: 11px;
      white-space: nowrap;
      padding: 2px 6px;
      border-radius: 4px;
      background: rgba(0,0,0,0.7);
    }

    #controlMarker { top: 30%; }
    #controlMarker::before { border-color: #4ade80; }
    #controlMarker .marker-label { color: #4ade80; }

    #testMarker { top: 50%; }
    #testMarker::before { border-color: #f472b6; }
    #testMarker .marker-label { color: #f472b6; }

    #baseMarker { top: 70%; }
    #baseMarker::before { border-color: #60a5fa; }
    #baseMarker .marker-label { color: #60a5fa; }

    .results {
      background: #252542;
      border-radius: 12px;
      padding: 20px;
      display: none;
    }

    .score {
      font-size: 3rem;
      font-weight: bold;
      text-align: center;
      margin: 10px 0;
    }

    .score-bar {
      height: 12px;
      background: linear-gradient(to right, #666, #f472b6);
      border-radius: 6px;
      position: relative;
      margin: 20px 0;
    }

    .score-indicator {
      position: absolute;
      top: -4px;
      width: 20px;
      height: 20px;
      background: white;
      border-radius: 50%;
      transform: translateX(-50%);
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      transition: left 0.3s;
    }

    .debug {
      font-size: 12px;
      color: #888;
      margin-top: 15px;
    }

    .debug-row {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      border-bottom: 1px solid #333;
    }

    .color-swatch {
      width: 40px;
      height: 20px;
      border-radius: 4px;
      display: inline-block;
      vertical-align: middle;
    }

    .instructions {
      font-size: 13px;
      color: #aaa;
      text-align: center;
      margin-bottom: 15px;
      line-height: 1.5;
    }

    button {
      width: 100%;
      padding: 14px;
      border: none;
      border-radius: 8px;
      background: #667eea;
      color: white;
      font-size: 1rem;
      cursor: pointer;
      margin-top: 15px;
    }

    button:hover {
      background: #5a67d8;
    }

    .graph-container {
      background: #252542;
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 20px;
      overflow: hidden;
    }

    .graph-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      gap: 10px;
    }

    .graph-header span {
      font-size: 14px;
      color: #aaa;
      text-align: center;
      white-space: nowrap;
    }

    .nav-btn {
      background: #374151;
      border: none;
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      white-space: nowrap;
    }

    .nav-btn:hover {
      background: #4b5563;
    }

    .nav-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    #graphCanvas {
      width: 100%;
      height: 250px;
      display: block;
    }

    .action-buttons {
      display: none;
      gap: 10px;
    }

    .action-btn {
      flex: 1;
      padding: 14px;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      cursor: pointer;
    }

    .action-btn.save {
      background: #667eea;
      color: white;
    }

    .action-btn.save:hover {
      background: #5a67d8;
    }

    .action-btn.cancel {
      background: #374151;
      color: white;
    }

    .action-btn.cancel:hover {
      background: #4b5563;
    }

    #newTestBtn {
      margin-top: 15px;
      max-width: 100%;
    }

    #manualEntryBtn {
      margin-top: 10px;
      max-width: 100%;
    }

    .manual-entry {
      display: none;
      background: #252542;
      border-radius: 12px;
      padding: 20px;
      margin-top: 15px;
    }

    .manual-entry-row {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 15px;
    }

    .manual-entry-row label {
      font-size: 14px;
      color: #aaa;
    }

    .manual-entry-row input {
      padding: 12px;
      border: 1px solid #444;
      border-radius: 8px;
      background: #1a1a2e;
      color: #eee;
      font-size: 16px;
    }

    .manual-entry-row input:focus {
      outline: none;
      border-color: #667eea;
    }

    .manual-entry-buttons {
      display: flex;
      gap: 10px;
    }

    .action-btn.delete {
      background: #dc2626;
      color: white;
    }

    .action-btn.delete:hover {
      background: #b91c1c;
    }

    .edit-title {
      font-size: 14px;
      color: #aaa;
      margin-bottom: 15px;
      text-align: center;
    }

    /* Test list styles */
    .test-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }

    .test-item {
      background: #252542;
      border-radius: 12px;
      padding: 16px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .test-item:hover {
      background: #2d2d4a;
    }

    .test-item-name {
      font-size: 1.1rem;
      font-weight: 500;
      margin-bottom: 4px;
    }

    .test-item-meta {
      font-size: 0.85rem;
      color: #888;
    }

    .create-test-form {
      display: none;
      background: #252542;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }

    .create-test-form input[type="text"] {
      width: 100%;
      padding: 12px;
      border: 1px solid #444;
      border-radius: 8px;
      background: #1a1a2e;
      color: #eee;
      font-size: 16px;
      margin-bottom: 15px;
    }

    .create-test-form input[type="text"]:focus {
      outline: none;
      border-color: #667eea;
    }

    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: #888;
    }

    .empty-state-icon {
      font-size: 3rem;
      margin-bottom: 10px;
    }
  </style></head> <body> <div class="container"> <a href="/pr-preview/pr-21/tools/" class="back-link" id="toolsLink">&larr; Back to Tools</a> <a href="#" class="back-link" id="backToListLink" style="display:none;">&larr; Back to Tests</a> <h1 id="pageTitle">Lateral Flow Test Reader</h1> <!-- Test List View --> <div id="testListView"> <div class="test-list" id="testList"></div> <div class="create-test-form" id="createTestForm"> <input type="text" id="newTestName" placeholder="Test name (e.g., COVID, Ovulation)"> <div class="manual-entry-buttons"> <button type="button" class="action-btn cancel" id="createCancelBtn">Cancel</button> <button type="button" class="action-btn save" id="createSaveBtn">Create</button> </div> </div> <button class="upload-btn" id="createTestBtn">+ Create Test</button> </div> <!-- Test Detail View (existing UI) --> <div id="testDetailView" style="display:none;"> <div class="upload-area" id="uploadArea"> <button type="button" class="upload-btn" id="fileBtn">Upload Photo</button> <input type="file" id="fileInput" accept="image/*"> </div> <div class="canvas-container" id="canvasContainer"> <canvas id="mainCanvas"></canvas> <div class="zoom-slider-container" id="zoomSliderContainer"> <div class="zoom-slider-track"> <label>Rotate</label> <input type="range" id="rotationSlider" min="-180" max="180" value="0" step="1"> <span id="rotationValue">0Â°</span> </div> <div class="zoom-slider-track"> <label>Zoom</label> <input type="range" id="zoomSlider" min="1" max="4" value="1" step="0.1"> <span id="zoomValue">1.0x</span> </div> </div> <div class="marker" id="controlMarker"> <span class="marker-label">Control</span> </div> <div class="marker" id="testMarker"> <span class="marker-label">Test</span> </div> <div class="marker" id="baseMarker"> <span class="marker-label">Base</span> </div> <!-- Crop handles --> <div class="crop-handle crop-left" id="cropLeft"></div> <div class="crop-handle crop-right" id="cropRight"></div> <div class="crop-overlay crop-overlay-left" id="cropOverlayLeft"></div> <div class="crop-overlay crop-overlay-right" id="cropOverlayRight"></div> </div> <div class="controls" id="controls"> <span class="control-hint">Drag edges to crop</span> </div> <p class="instructions" id="instructions" style="display:none;">
Drag markers to align:<br> <span style="color:#4ade80">Green</span> â†’ Control line &nbsp;
<span style="color:#f472b6">Pink</span> â†’ Test line &nbsp;
<span style="color:#60a5fa">Blue</span> â†’ Base/background
</p> <div class="results" id="results"> <div style="text-align:center;color:#888;">Test / Control Ratio</div> <div class="score" id="scoreValue">0.00</div> <div class="score-bar"> <div class="score-indicator" id="scoreIndicator"></div> </div> <div class="debug" id="debug"></div> </div> <div class="graph-container" id="graphContainer"> <div class="graph-header"> <button type="button" class="nav-btn" id="prevBtn">â—€ 15 days</button> <span id="dateRange"></span> <button type="button" class="nav-btn" id="nextBtn">15 days â–¶</button> </div> <canvas id="graphCanvas"></canvas> </div> <button class="upload-btn" id="newTestBtn" style="display:none;">+ New Test</button> <button class="upload-btn secondary" id="manualEntryBtn" style="display:none;">Manual Entry</button> <div class="manual-entry" id="manualEntry"> <div class="manual-entry-row"> <label for="manualScore">Score:</label> <input type="number" id="manualScore" min="0" step="0.01" value="0.5"> </div> <div class="manual-entry-row"> <label for="manualDate">Date & Time:</label> <input type="datetime-local" id="manualDate"> </div> <div class="manual-entry-buttons"> <button type="button" class="action-btn cancel" id="manualCancelBtn">Cancel</button> <button type="button" class="action-btn save" id="manualSaveBtn">Save</button> </div> </div> <div class="manual-entry" id="editEntry"> <div class="edit-title">Edit Test Result</div> <div class="manual-entry-row"> <label for="editScore">Score:</label> <input type="number" id="editScore" min="0" step="0.01" value="0.5"> </div> <div class="manual-entry-row"> <label for="editDate">Date & Time:</label> <input type="datetime-local" id="editDate"> </div> <div class="manual-entry-buttons"> <button type="button" class="action-btn delete" id="editDeleteBtn">Delete</button> <button type="button" class="action-btn cancel" id="editCancelBtn">Cancel</button> <button type="button" class="action-btn save" id="editSaveBtn">Save</button> </div> </div> <div class="action-buttons" id="actionButtons"> <button id="cancelBtn" class="action-btn cancel">Cancel</button> <button id="saveBtn" class="action-btn save">Save</button> </div> </div><!-- /testDetailView --> </div> <script>
    // DOM elements - List view
    const testListView = document.getElementById('testListView');
    const testList = document.getElementById('testList');
    const createTestBtn = document.getElementById('createTestBtn');
    const createTestForm = document.getElementById('createTestForm');
    const newTestName = document.getElementById('newTestName');
    const createSaveBtn = document.getElementById('createSaveBtn');
    const createCancelBtn = document.getElementById('createCancelBtn');
    const toolsLink = document.getElementById('toolsLink');
    const backToListLink = document.getElementById('backToListLink');
    const pageTitle = document.getElementById('pageTitle');

    // DOM elements - Detail view
    const testDetailView = document.getElementById('testDetailView');
    const fileInput = document.getElementById('fileInput');
    const fileBtn = document.getElementById('fileBtn');
    const uploadArea = document.getElementById('uploadArea');
    const canvasContainer = document.getElementById('canvasContainer');
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const results = document.getElementById('results');
    const instructions = document.getElementById('instructions');
    const controls = document.getElementById('controls');
    const saveBtn = document.getElementById('saveBtn');
    const cancelBtn = document.getElementById('cancelBtn');
    const actionButtons = document.getElementById('actionButtons');
    const graphContainer = document.getElementById('graphContainer');
    const graphCanvas = document.getElementById('graphCanvas');
    const graphCtx = graphCanvas.getContext('2d');
    const newTestBtn = document.getElementById('newTestBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const dateRangeSpan = document.getElementById('dateRange');
    const manualEntryBtn = document.getElementById('manualEntryBtn');
    const manualEntry = document.getElementById('manualEntry');
    const manualScore = document.getElementById('manualScore');
    const manualDate = document.getElementById('manualDate');
    const manualSaveBtn = document.getElementById('manualSaveBtn');
    const manualCancelBtn = document.getElementById('manualCancelBtn');
    const editEntry = document.getElementById('editEntry');
    const editScore = document.getElementById('editScore');
    const editDate = document.getElementById('editDate');
    const editSaveBtn = document.getElementById('editSaveBtn');
    const editCancelBtn = document.getElementById('editCancelBtn');
    const editDeleteBtn = document.getElementById('editDeleteBtn');
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomValue = document.getElementById('zoomValue');

    const markers = {
      control: document.getElementById('controlMarker'),
      test: document.getElementById('testMarker'),
      base: document.getElementById('baseMarker')
    };

    const cropLeft = document.getElementById('cropLeft');
    const cropRight = document.getElementById('cropRight');
    const cropOverlayLeft = document.getElementById('cropOverlayLeft');
    const cropOverlayRight = document.getElementById('cropOverlayRight');

    let img = null;
    let rotation = 0; // degrees
    let cropLeftPercent = 0;
    let cropRightPercent = 0;
    let scale = 1;
    let zoom = 1;
    let activeMarker = null;
    let activeCropHandle = null;
    let currentScore = 0;
    let editingIndex = -1; // index of entry being edited

    // Data storage - new model
    const STORAGE_KEY = 'testReaderData';
    let appData = loadData();
    let currentTestId = null;
    let testData = []; // current test's data
    let graphOffset = 0;
    let graphPadding = { top: 20, right: 10, bottom: 40, left: 35 };

    function loadData() {
      // Try new format first
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        return JSON.parse(saved);
      }

      // Migrate from old format
      const oldData = localStorage.getItem('ovulationTests');
      if (oldData) {
        const migratedData = {
          tests: [{
            id: generateId(),
            name: 'Migrated Data',
            createdAt: new Date().toISOString(),
            data: JSON.parse(oldData)
          }]
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(migratedData));
        localStorage.removeItem('ovulationTests');
        return migratedData;
      }

      // Fresh start
      return { tests: [] };
    }

    function saveData() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(appData));
    }

    function generateId() {
      return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }

    function getCurrentTest() {
      return appData.tests.find(t => t.id === currentTestId);
    }

    // Initialize
    showTestList();

    // ========== TEST LIST VIEW ==========

    function showTestList() {
      testListView.style.display = 'block';
      testDetailView.style.display = 'none';
      toolsLink.style.display = 'inline';
      backToListLink.style.display = 'none';
      pageTitle.textContent = 'Lateral Flow Test Reader';
      createTestForm.style.display = 'none';
      createTestBtn.style.display = 'block';
      currentTestId = null;
      renderTestList();
    }

    function renderTestList() {
      if (appData.tests.length === 0) {
        testList.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">ðŸ“‹</div>
            <p>No tests yet.<br>Create one to get started.</p>
          </div>
        `;
        return;
      }

      testList.innerHTML = appData.tests.map(test => {
        const entryCount = test.data.length;
        const lastEntry = test.data.length > 0
          ? new Date(test.data[test.data.length - 1].timestamp).toLocaleDateString()
          : 'No entries';
        return `
          <div class="test-item" data-id="${test.id}">
            <div class="test-item-name">${escapeHtml(test.name)}</div>
            <div class="test-item-meta">${entryCount} entries Â· Last: ${lastEntry}</div>
          </div>
        `;
      }).join('');

      // Add click handlers
      testList.querySelectorAll('.test-item').forEach(item => {
        item.addEventListener('click', () => {
          openTest(item.dataset.id);
        });
      });
    }

    function escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    function openTest(testId) {
      currentTestId = testId;
      const test = getCurrentTest();
      if (!test) return;

      testData = test.data;
      testListView.style.display = 'none';
      testDetailView.style.display = 'block';
      toolsLink.style.display = 'none';
      backToListLink.style.display = 'inline';
      pageTitle.textContent = test.name;

      showGraphView();
    }

    // Create test form handlers
    createTestBtn.addEventListener('click', () => {
      createTestForm.style.display = 'block';
      createTestBtn.style.display = 'none';
      newTestName.value = '';
      newTestName.focus();
    });

    createCancelBtn.addEventListener('click', () => {
      createTestForm.style.display = 'none';
      createTestBtn.style.display = 'block';
    });

    createSaveBtn.addEventListener('click', () => {
      const name = newTestName.value.trim();
      if (!name) {
        alert('Please enter a test name');
        return;
      }

      const newTest = {
        id: generateId(),
        name: name,
        createdAt: new Date().toISOString(),
        data: []
      };
      appData.tests.push(newTest);
      saveData();

      createTestForm.style.display = 'none';
      createTestBtn.style.display = 'block';
      openTest(newTest.id);
    });

    newTestName.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        createSaveBtn.click();
      } else if (e.key === 'Escape') {
        createCancelBtn.click();
      }
    });

    // Back to list
    backToListLink.addEventListener('click', (e) => {
      e.preventDefault();
      showTestList();
    });

    // ========== TEST DETAIL VIEW ==========

    // Upload handling
    fileBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', handleFile);

    function handleFile(e) {
      const file = e.target.files[0];
      if (!file) return;

      img = new Image();
      img.onload = () => {
        rotation = 0;
        rotationSlider.value = 0;
        rotationValue.textContent = '0Â°';
        zoom = 1;
        zoomSlider.value = 1;
        zoomValue.textContent = '1.0x';
        cropLeftPercent = 0;
        cropRightPercent = 0;

        redrawCanvas();

        // Show test UI, hide graph
        uploadArea.style.display = 'none';
        graphContainer.style.display = 'none';
        newTestBtn.style.display = 'none';
        canvasContainer.style.display = 'block';
        controls.style.display = 'flex';
        instructions.style.display = 'block';
        results.style.display = 'block';
        actionButtons.style.display = 'flex';

        // Reset marker positions
        markers.control.style.top = '25%';
        markers.test.style.top = '45%';
        markers.base.style.top = '65%';

        updateCropHandles();
        calculateScore();
      };
      img.src = URL.createObjectURL(file);
    }

    function redrawCanvas() {
      if (!img) return;

      const maxWidth = canvasContainer.parentElement.clientWidth;

      // Always use original image dimensions for canvas size (no rotation-based resizing)
      scale = Math.min(1, maxWidth / img.width);

      canvas.width = img.width * scale;
      canvas.height = img.height * scale;

      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.rotate((rotation * Math.PI) / 180);

      // Apply zoom centered on the crop region
      const cropCenterPercent = cropLeftPercent + (100 - cropLeftPercent - cropRightPercent) / 2;
      const cropCenterX = (cropCenterPercent / 100 - 0.5) * canvas.width;
      ctx.translate(-cropCenterX * (zoom - 1), 0);
      ctx.scale(zoom, zoom);

      const drawWidth = img.width * scale;
      const drawHeight = img.height * scale;
      ctx.drawImage(img, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
      ctx.restore();

      // Defer score calculation until canvas is rendered
      requestAnimationFrame(() => calculateScore());
    }

    // Rotation slider
    const rotationSlider = document.getElementById('rotationSlider');
    const rotationValue = document.getElementById('rotationValue');

    rotationSlider.addEventListener('input', () => {
      rotation = parseInt(rotationSlider.value, 10);
      rotationValue.textContent = rotation + 'Â°';
      redrawCanvas();
    });

    // Zoom slider
    zoomSlider.addEventListener('input', () => {
      zoom = parseFloat(zoomSlider.value);
      zoomValue.textContent = zoom.toFixed(1) + 'x';
      redrawCanvas();
    });

    // Crop handle dragging
    cropLeft.addEventListener('mousedown', (e) => startCropDrag(e, 'left'));
    cropLeft.addEventListener('touchstart', (e) => startCropDrag(e, 'left'), { passive: false });
    cropRight.addEventListener('mousedown', (e) => startCropDrag(e, 'right'));
    cropRight.addEventListener('touchstart', (e) => startCropDrag(e, 'right'), { passive: false });

    function startCropDrag(e, side) {
      e.preventDefault();
      e.stopPropagation();
      activeCropHandle = side;
    }

    document.addEventListener('mousemove', handleDrag);
    document.addEventListener('touchmove', handleDrag, { passive: false });
    document.addEventListener('mouseup', endDrag);
    document.addEventListener('touchend', endDrag);

    function handleDrag(e) {
      if (activeCropHandle) {
        e.preventDefault();
        const rect = canvasContainer.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const x = clientX - rect.left;
        const percent = Math.max(0, Math.min(100, (x / rect.width) * 100));

        if (activeCropHandle === 'left') {
          cropLeftPercent = Math.min(percent, 100 - cropRightPercent - 10);
        } else {
          cropRightPercent = Math.min(100 - percent, 100 - cropLeftPercent - 10);
        }

        updateCropHandles();
        calculateScore();
      } else if (activeMarker) {
        drag(e);
      }
    }

    function updateCropHandles() {
      cropLeft.style.left = cropLeftPercent + '%';
      cropRight.style.right = cropRightPercent + '%';
      cropOverlayLeft.style.width = cropLeftPercent + '%';
      cropOverlayRight.style.width = cropRightPercent + '%';
    }

    // Marker dragging
    Object.values(markers).forEach(marker => {
      marker.addEventListener('mousedown', startMarkerDrag);
      marker.addEventListener('touchstart', startMarkerDrag, { passive: false });
    });

    function startMarkerDrag(e) {
      e.preventDefault();
      activeMarker = e.currentTarget;
    }

    function drag(e) {
      if (!activeMarker) return;
      e.preventDefault();

      const rect = canvasContainer.getBoundingClientRect();
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      const y = clientY - rect.top;
      const percent = Math.max(5, Math.min(95, (y / rect.height) * 100));

      activeMarker.style.top = percent + '%';
      calculateScore();
    }

    function endDrag() {
      activeMarker = null;
      activeCropHandle = null;
    }

    // Score calculation
    function calculateScore() {
      if (!img || canvas.width === 0 || canvas.height === 0) return;

      const canvasRect = canvas.getBoundingClientRect();
      if (canvasRect.height === 0 || canvasRect.width === 0) return; // not rendered yet

      // Get Y positions in canvas coordinates
      const getY = (marker) => {
        const markerRect = marker.getBoundingClientRect();
        const y = markerRect.top + markerRect.height / 2 - canvasRect.top;
        return Math.round(y * (canvas.height / canvasRect.height));
      };

      const controlY = getY(markers.control);
      const testY = getY(markers.test);
      const baseY = getY(markers.base);

      // Sample horizontal strip (within crop bounds)
      const cropLeftPx = Math.round(canvas.width * (cropLeftPercent / 100));
      const cropRightPx = Math.round(canvas.width * (cropRightPercent / 100));
      const croppedWidth = canvas.width - cropLeftPx - cropRightPx;
      if (croppedWidth < 10) return; // too narrow to sample

      const startX = cropLeftPx + Math.round(croppedWidth * 0.1);
      const endX = canvas.width - cropRightPx - Math.round(croppedWidth * 0.1);
      const sampleWidth = Math.max(1, endX - startX);
      if (sampleWidth < 1 || startX < 0 || startX >= canvas.width) return;

      const sampleStrip = (y) => {
        // Sample 3 rows and average for noise reduction
        let r = 0, g = 0, b = 0;
        const rows = [-1, 0, 1];
        let count = 0;

        for (const dy of rows) {
          const sy = Math.max(0, Math.min(canvas.height - 1, y + dy));
          const imageData = ctx.getImageData(startX, sy, sampleWidth, 1).data;

          for (let i = 0; i < imageData.length; i += 4) {
            r += imageData[i];
            g += imageData[i + 1];
            b += imageData[i + 2];
            count++;
          }
        }

        return {
          r: r / count,
          g: g / count,
          b: b / count
        };
      };

      const controlColor = sampleStrip(controlY);
      const testColor = sampleStrip(testY);
      const baseColor = sampleStrip(baseY);

      // Calculate intensity relative to base
      // For LH tests, we're looking at how much darker/more saturated the line is
      // Using inverse of lightness as "intensity" (darker = more intense)
      const getIntensity = (color, base) => {
        // Calculate how much the color differs from base (whiter = less intense)
        const colorLightness = (color.r + color.g + color.b) / 3;
        const baseLightness = (base.r + base.g + base.b) / 3;

        // Intensity is how much darker than base
        // Normalized so base=0 intensity, pure black = max intensity
        const intensity = Math.max(0, baseLightness - colorLightness);
        return intensity;
      };

      const controlIntensity = getIntensity(controlColor, baseColor);
      const testIntensity = getIntensity(testColor, baseColor);

      // Ratio: test / control
      let ratio = 0;
      if (controlIntensity > 5) { // Minimum threshold to avoid division issues
        ratio = testIntensity / controlIntensity;
      }

      // Update UI
      document.getElementById('scoreValue').textContent = ratio.toFixed(2);
      document.getElementById('scoreIndicator').style.left = (ratio * 100) + '%';
      currentScore = ratio;

      // Debug info
      const colorBox = (c) => `<span class="color-swatch" style="background:rgb(${Math.round(c.r)},${Math.round(c.g)},${Math.round(c.b)})"></span>`;

      document.getElementById('debug').innerHTML = `
        <div class="debug-row">
          <span>Control line</span>
          <span>${colorBox(controlColor)} intensity: ${controlIntensity.toFixed(1)}</span>
        </div>
        <div class="debug-row">
          <span>Test line</span>
          <span>${colorBox(testColor)} intensity: ${testIntensity.toFixed(1)}</span>
        </div>
        <div class="debug-row">
          <span>Base/background</span>
          <span>${colorBox(baseColor)}</span>
        </div>
      `;
    }

    // Save button
    saveBtn.addEventListener('click', () => {
      const entry = {
        score: currentScore,
        timestamp: new Date().toISOString()
      };
      testData.push(entry);
      const test = getCurrentTest();
      if (test) {
        test.data = testData;
        saveData();
      }
      showGraphView();
    });

    // Cancel button
    cancelBtn.addEventListener('click', () => {
      showGraphView();
    });

    // New test button
    newTestBtn.addEventListener('click', () => {
      uploadArea.style.display = 'block';
      newTestBtn.style.display = 'none';
      manualEntryBtn.style.display = 'none';
      manualEntry.style.display = 'none';
    });

    // Manual entry button
    manualEntryBtn.addEventListener('click', () => {
      // Set default date to now
      const now = new Date();
      now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
      manualDate.value = now.toISOString().slice(0, 16);
      manualScore.value = '0.5';

      manualEntry.style.display = 'block';
      newTestBtn.style.display = 'none';
      manualEntryBtn.style.display = 'none';
    });

    // Manual save
    manualSaveBtn.addEventListener('click', () => {
      const score = parseFloat(manualScore.value);
      if (isNaN(score) || score <= 0) {
        alert('Score must be greater than 0');
        return;
      }

      const dateVal = manualDate.value;
      if (!dateVal) {
        alert('Please select a date and time');
        return;
      }

      const entry = {
        score: score,
        timestamp: new Date(dateVal).toISOString(),
        manual: true
      };
      testData.push(entry);
      const test = getCurrentTest();
      if (test) {
        test.data = testData;
        saveData();
      }

      manualEntry.style.display = 'none';
      newTestBtn.style.display = 'block';
      manualEntryBtn.style.display = 'block';
      drawGraph();
    });

    // Manual cancel
    manualCancelBtn.addEventListener('click', () => {
      manualEntry.style.display = 'none';
      newTestBtn.style.display = 'block';
      manualEntryBtn.style.display = 'block';
    });

    // Graph click to edit
    graphCanvas.addEventListener('click', (e) => {
      const rect = graphCanvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;

      const w = rect.width;
      const h = rect.height;
      const graphW = w - graphPadding.left - graphPadding.right;
      const graphH = h - graphPadding.top - graphPadding.bottom;

      // Calculate date range (same as drawGraph)
      const endDate = new Date();
      endDate.setDate(endDate.getDate() + 1 - graphOffset);
      endDate.setHours(0, 0, 0, 0);
      const startDate = new Date(endDate);
      startDate.setDate(startDate.getDate() - 29);
      const endOfEndDate = new Date(endDate);
      endOfEndDate.setHours(23, 59, 59, 999);

      // Calculate yMax (same as drawGraph)
      const rangeData = testData.filter(entry => {
        const d = new Date(entry.timestamp);
        return d >= startDate && d <= endOfEndDate;
      });
      const maxScore = rangeData.length > 0 ? Math.max(...rangeData.map(e => e.score)) : 0;
      const yMax = Math.max(1, maxScore);

      // Find clicked point
      const clickRadius = 15;
      let clickedIndex = -1;

      for (let i = 0; i < testData.length; i++) {
        const entry = testData[i];
        const d = new Date(entry.timestamp);
        if (d < startDate || d > endOfEndDate) continue;

        const daysDiff = (d - startDate) / (1000 * 60 * 60 * 24);
        const px = graphPadding.left + (daysDiff / 29) * graphW;
        const py = graphPadding.top + graphH - (entry.score / yMax) * graphH;

        const dist = Math.sqrt((clickX - px) ** 2 + (clickY - py) ** 2);
        if (dist < clickRadius) {
          clickedIndex = i;
          break;
        }
      }

      if (clickedIndex >= 0) {
        openEditForm(clickedIndex);
      }
    });

    function openEditForm(index) {
      editingIndex = index;
      const entry = testData[index];

      // Populate form
      editScore.value = entry.score.toFixed(2);
      const d = new Date(entry.timestamp);
      d.setMinutes(d.getMinutes() - d.getTimezoneOffset());
      editDate.value = d.toISOString().slice(0, 16);

      // Show edit form, hide buttons
      editEntry.style.display = 'block';
      newTestBtn.style.display = 'none';
      manualEntryBtn.style.display = 'none';
      manualEntry.style.display = 'none';
    }

    // Edit save
    editSaveBtn.addEventListener('click', () => {
      const score = parseFloat(editScore.value);
      if (isNaN(score) || score <= 0) {
        alert('Score must be greater than 0');
        return;
      }

      const dateVal = editDate.value;
      if (!dateVal) {
        alert('Please select a date and time');
        return;
      }

      testData[editingIndex].score = score;
      testData[editingIndex].timestamp = new Date(dateVal).toISOString();
      const test = getCurrentTest();
      if (test) {
        test.data = testData;
        saveData();
      }

      editEntry.style.display = 'none';
      newTestBtn.style.display = 'block';
      manualEntryBtn.style.display = 'block';
      editingIndex = -1;
      drawGraph();
    });

    // Edit cancel
    editCancelBtn.addEventListener('click', () => {
      editEntry.style.display = 'none';
      newTestBtn.style.display = 'block';
      manualEntryBtn.style.display = 'block';
      editingIndex = -1;
    });

    // Edit delete
    editDeleteBtn.addEventListener('click', () => {
      if (confirm('Delete this test result?')) {
        testData.splice(editingIndex, 1);
        const test = getCurrentTest();
        if (test) {
          test.data = testData;
          saveData();
        }

        editEntry.style.display = 'none';
        newTestBtn.style.display = 'block';
        manualEntryBtn.style.display = 'block';
        editingIndex = -1;
        drawGraph();
      }
    });

    // Graph navigation
    prevBtn.addEventListener('click', () => {
      graphOffset += 15;
      drawGraph();
    });

    nextBtn.addEventListener('click', () => {
      graphOffset = Math.max(0, graphOffset - 15);
      drawGraph();
    });

    function showGraphView() {
      // Hide test UI
      uploadArea.style.display = 'none';
      canvasContainer.style.display = 'none';
      controls.style.display = 'none';
      instructions.style.display = 'none';
      results.style.display = 'none';
      actionButtons.style.display = 'none';
      fileInput.value = '';
      img = null;

      // Show graph
      graphContainer.style.display = 'block';
      newTestBtn.style.display = 'block';
      manualEntryBtn.style.display = 'block';
      manualEntry.style.display = 'none';
      editEntry.style.display = 'none';
      editingIndex = -1;
      graphOffset = 0;
      drawGraph();
    }

    function drawGraph() {
      const dpr = window.devicePixelRatio || 1;
      const rect = graphCanvas.getBoundingClientRect();
      graphCanvas.width = rect.width * dpr;
      graphCanvas.height = rect.height * dpr;
      graphCtx.scale(dpr, dpr);

      const w = rect.width;
      const h = rect.height;
      const padding = { top: 20, right: 10, bottom: 40, left: 35 };
      const graphW = w - padding.left - padding.right;
      const graphH = h - padding.top - padding.bottom;

      // Clear
      graphCtx.fillStyle = '#252542';
      graphCtx.fillRect(0, 0, w, h);

      // Calculate date range - end at tomorrow, go back 30 days
      const endDate = new Date();
      endDate.setDate(endDate.getDate() + 1 - graphOffset); // tomorrow
      endDate.setHours(0, 0, 0, 0);

      const startDate = new Date(endDate);
      startDate.setDate(startDate.getDate() - 29); // 30 days total

      // Update date range display
      const formatDate = (d) => d.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' });
      dateRangeSpan.textContent = `${formatDate(startDate)} â€“ ${formatDate(endDate)}`;

      // Disable next button if at today
      nextBtn.disabled = graphOffset === 0;

      // Filter data to this range (include all of endDate day)
      const endOfEndDate = new Date(endDate);
      endOfEndDate.setHours(23, 59, 59, 999);

      const rangeData = testData.filter(entry => {
        const d = new Date(entry.timestamp);
        return d >= startDate && d <= endOfEndDate;
      });

      // Calculate Y-axis max: at least 1, or higher if data exceeds 1
      const maxScore = rangeData.length > 0 ? Math.max(...rangeData.map(e => e.score)) : 0;
      const yMax = Math.max(1, maxScore);

      // Draw vertical grid lines for each day
      graphCtx.font = '10px -apple-system, sans-serif';
      graphCtx.textAlign = 'center';

      for (let i = 0; i < 30; i++) {
        const x = padding.left + (i / 29) * graphW;
        const d = new Date(startDate);
        d.setDate(d.getDate() + i);

        // Vertical line
        graphCtx.strokeStyle = '#3a3a5a';
        graphCtx.lineWidth = 1;
        graphCtx.beginPath();
        graphCtx.moveTo(x, padding.top);
        graphCtx.lineTo(x, padding.top + graphH);
        graphCtx.stroke();

        // Date label
        graphCtx.fillStyle = '#666';
        graphCtx.fillText(d.getDate(), x, h - 8);
      }

      // Horizontal grid (0 to yMax in 4 steps)
      for (let i = 0; i <= 4; i++) {
        const y = padding.top + graphH - (i / 4) * graphH;
        graphCtx.strokeStyle = '#3a3a5a';
        graphCtx.lineWidth = 1;
        graphCtx.beginPath();
        graphCtx.moveTo(padding.left, y);
        graphCtx.lineTo(w - padding.right, y);
        graphCtx.stroke();

        // Labels
        graphCtx.fillStyle = '#888';
        graphCtx.font = '11px -apple-system, sans-serif';
        graphCtx.textAlign = 'right';
        graphCtx.fillText((i * yMax / 4).toFixed(2), padding.left - 5, y + 4);
      }

      // Draw points and lines
      if (rangeData.length > 0) {
        // Sort by timestamp
        rangeData.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        const getX = (timestamp) => {
          const d = new Date(timestamp);
          const daysDiff = (d - startDate) / (1000 * 60 * 60 * 24);
          return padding.left + (daysDiff / 29) * graphW;
        };

        const getY = (score) => {
          return padding.top + graphH - (score / yMax) * graphH;
        };

        // Draw line
        graphCtx.strokeStyle = '#f472b6';
        graphCtx.lineWidth = 2;
        graphCtx.beginPath();
        rangeData.forEach((entry, i) => {
          const x = getX(entry.timestamp);
          const y = getY(entry.score);
          if (i === 0) {
            graphCtx.moveTo(x, y);
          } else {
            graphCtx.lineTo(x, y);
          }
        });
        graphCtx.stroke();

        // Draw points
        rangeData.forEach(entry => {
          const x = getX(entry.timestamp);
          const y = getY(entry.score);

          graphCtx.fillStyle = '#f472b6';
          graphCtx.beginPath();
          graphCtx.arc(x, y, 5, 0, Math.PI * 2);
          graphCtx.fill();

          graphCtx.fillStyle = '#252542';
          graphCtx.beginPath();
          graphCtx.arc(x, y, 2, 0, Math.PI * 2);
          graphCtx.fill();
        });
      }

      // "No data" message
      if (rangeData.length === 0) {
        graphCtx.fillStyle = '#666';
        graphCtx.font = '14px -apple-system, sans-serif';
        graphCtx.textAlign = 'center';
        graphCtx.fillText('No tests in this period', w / 2, h / 2);
      }
    }

    // Handle resize
    window.addEventListener('resize', () => {
      if (graphContainer.style.display !== 'none') {
        drawGraph();
      }
    });
  </script> </body> </html>